diff -ruN ../wings/server/manager.go ./server/manager.go
--- ../wings/server/manager.go  2025-08-04 20:06:05.868659711 +0000
+++ ./server/manager.go 2025-08-04 20:06:43.900821631 +0000
@@ -268,6 +268,10 @@
                                return
                        }
                        m.Add(s)
+                       // spoof if servers offline
+                       if s.Environment.State() == environment.ProcessOfflineState {
+                               s.startSpoof()
+                       }
                })
        }

diff -ruN ../wings/server/power.go ./server/power.go
--- ../wings/server/power.go    2025-08-04 20:06:05.868659711 +0000
+++ ./server/power.go   2025-08-04 20:06:40.636807750 +0000
@@ -1,8 +1,15 @@
 package server

 import (
+       "bufio"
+       "bytes"
        "context"
+       "encoding/json"
        "fmt"
+       "io"
+       "net"
+       "strings"
+       "sync"
        "time"

        "emperror.dev/errors"
@@ -12,6 +19,11 @@
        "github.com/pterodactyl/wings/environment"
 )

+var (
+       spoofers   = make(map[string]net.Listener)
+       spoofersMu sync.Mutex
+)
+
 type PowerAction string

 // The power actions that can be performed for a given server. This taps into the given server
@@ -150,6 +162,7 @@
                }

                if action == PowerActionStop {
+                       s.startSpoof()
                        return nil
                }

@@ -169,6 +182,7 @@
 // Execute a few functions before actually calling the environment start commands. This ensures
 // that everything is ready to go for environment booting, and that the server can even be started.
 func (s *Server) onBeforeStart() error {
+       s.stopSpoof()
        s.Log().Info("syncing server configuration with panel")
        if err := s.Sync(); err != nil {
                return errors.WithMessage(err, "unable to sync server data from Panel instance")
@@ -217,3 +231,244 @@
        s.Log().Info("completed server preflight, starting boot process...")
        return nil
 }
+
+func (s *Server) startSpoof() {
+       ip := s.Config().Allocations.DefaultMapping.Ip
+       port := s.Config().Allocations.DefaultMapping.Port
+       addr := fmt.Sprintf("%s:%d", ip, port)
+
+       ln, err := net.Listen("tcp", addr)
+       if err != nil {
+               s.Log().WithField("address", addr).WithField("error", err).Warn("got err")
+               return
+       }
+
+       spoofersMu.Lock()
+       if l, ok := spoofers[s.ID()]; ok {
+               l.Close()
+       }
+       spoofers[s.ID()] = ln
+       spoofersMu.Unlock()
+
+       s.Log().WithField("address", addr).Info("[spoofer] listening")
+
+       go func() {
+               defer func() {
+                       spoofersMu.Lock()
+                       delete(spoofers, s.ID())
+                       spoofersMu.Unlock()
+                       ln.Close()
+               }()
+
+               for {
+                       conn, err := ln.Accept()
+                       if err != nil {
+                               return 
+                       }
+                       go handleSpoofedConnection(conn, s)
+               }
+       }()
+}
+
+func (s *Server) stopSpoof() {
+       spoofersMu.Lock()
+       defer spoofersMu.Unlock()
+       if l, ok := spoofers[s.ID()]; ok {
+               s.Log().Info("stopping spoofed minecraft listener")
+               l.Close()
+               delete(spoofers, s.ID())
+       }
+}
+
+func handleSpoofedConnection(conn net.Conn, s *Server) {
+       defer conn.Close()
+       // Set a deadline to prevent connections from hanging.
+       if err := conn.SetDeadline(time.Now().Add(5 * time.Second)); err != nil {
+               return
+       }
+
+       // Create a buffered reader to peek at the incoming data.
+       reader := bufio.NewReader(conn)
+
+       // Peek at the first 4 bytes to see if it's an HTTP request.
+       peekedBytes, err := reader.Peek(4)
+       if err == nil {
+               method := string(peekedBytes)
+               if strings.HasPrefix(method, "GET ") || strings.HasPrefix(method, "POST") || strings.HasPrefix(method, "HEAD") || strings.HasPrefix(method, "PUT ") {
+                       // It's an HTTP request, send an HTML response.
+                       response := "HTTP/1.1 200 OK\r\nContent-Type: text/html; charset=utf-8\r\n\r\n<html><head> <meta charset=\"UTF-8\"> <title>Server Offline</title> </head><body><h3>This server is offline.</h3></body></html>"
                        _, _ = conn.Write([]byte(response))
                        return
+               }
+       }
+
+       // 1. Read Handshake
+       // Packet Length
+       if _, err := readVarInt(reader); err != nil {
+               return
+       }
+       packetID, err := readVarInt(reader)
+       if err != nil || packetID != 0x00 {
+               return
+       }
+       protocolVersion, err := readVarInt(reader)
+       if err != nil {
+               return
+       }
+       serverAddressLen, err := readVarInt(reader)
+       if err != nil {
+               return
+       }
+       if _, err := io.CopyN(io.Discard, reader, int64(serverAddressLen)); err != nil {
+               return
+       }
+       // Port
+       if _, err := io.CopyN(io.Discard, reader, 2); err != nil {
+               return
+       }
+       nextState, err := readVarInt(reader)
+       if err != nil {
+               return
+       }
+
+       // We only care about status requests (state 1).
+       if nextState != 1 {
+               return
+       }
+
+       // 2. Read Status Request
+       // Packet Length
+       if _, err := readVarInt(reader); err != nil {
+               return
+       }
+       packetID, err = readVarInt(reader)
+       if err != nil || packetID != 0x00 {
+               return
+       }
+
+       // 3. Write Status Response
+       motd := "\u00a7l   \u00a7c              \u2718 This server is offline!\u00a7r\n\u00a7l   \u00a7b                powered by OneVM.eu"
+       response := MCOfflineResponse{
+               Version:     MCOfflineVersion{Name: "Offline", Protocol: int(protocolVersion)},
+               Players:     MCOfflinePlayers{Max: 0, Online: 0, Sample: []PlayerSample{{Name: "onevm.eu", ID: "00000000-0000-0000-0000-000000000000"}}},
+               Description: MCOfflineDescription{Text: motd},
+       }
+       jsonResponse, err := json.Marshal(response)
+       if err != nil {
+               s.Log().WithField("error", err).Warn("failed to marshal spoof response")
+               return
+       }
+
+       responseBody := new(bytes.Buffer)
+       // Packet ID
+       writeVarInt(responseBody, 0x00)
+       writeString(responseBody, string(jsonResponse))
+
+       packet := new(bytes.Buffer)
+       writeVarInt(packet, int32(responseBody.Len()))
+       packet.Write(responseBody.Bytes())
+       if _, err := conn.Write(packet.Bytes()); err != nil {
+               return
+       }
+
+       // 4. Handle Ping/Pong
+       pingPacketLen, err := readVarInt(reader)
+       if err != nil {
+               return
+       }
+       pingPacketID, err := readVarInt(reader)
+       if err != nil || pingPacketID != 0x01 {
+               return
+       }
+
+       payload := make([]byte, pingPacketLen-1)
+       if _, err := io.ReadFull(reader, payload); err != nil {
+               return
+       }
+
+       pongBody := new(bytes.Buffer)
+       // Packet ID
+       writeVarInt(pongBody, 0x01)
+       pongBody.Write(payload)
+
+       packet.Reset()
+       writeVarInt(packet, int32(pongBody.Len()))
+       packet.Write(pongBody.Bytes())
+       if _, err := conn.Write(packet.Bytes()); err != nil {
+               return
+       }
+}
+
+// MCOfflineResponse is the response to a Minecraft status request when the server is offline.
+type MCOfflineResponse struct {
+       Version     MCOfflineVersion     `json:"version"`
+       Players     MCOfflinePlayers     `json:"players"`
+       Description MCOfflineDescription `json:"description"`
+}
+
+type MCOfflineVersion struct {
+       Name     string `json:"name"`
+       Protocol int    `json:"protocol"`
+}
+
+type MCOfflinePlayers struct {
+       Max    int            `json:"max"`
+       Online int            `json:"online"`
+       Sample []PlayerSample `json:"sample,omitempty"`
+}
+
+type PlayerSample struct {
+       Name string `json:"name"`
+       ID   string `json:"id"`
+}
+
+type MCOfflineDescription struct {
+       Text string `json:"text"`
+}
+
+// readVarInt reads a VarInt from a reader.
+func readVarInt(r io.Reader) (int32, error) {
+       var value int32
+       var position int
+       var currentByte byte
+
+       for {
+               b := make([]byte, 1)
+               _, err := r.Read(b)
+               if err != nil {
+                       return 0, err
+               }
+               currentByte = b[0]
+
+               value |= int32(currentByte&0x7F) << position
+
+               if (currentByte & 0x80) == 0 {
+                       break
+               }
+
+               position += 7
+
+               if position >= 32 {
+                       return 0, errors.New("VarInt is too big")
+               }
+       }
+       return value, nil
+}
+
+// writeVarInt writes a VarInt to a writer.
+func writeVarInt(w io.Writer, value int32) {
+       for {
+               if (value & ^0x7F) == 0 {
+                       _, _ = w.Write([]byte{byte(value)})
+                       return
+               }
+               _, _ = w.Write([]byte{byte((value & 0x7F) | 0x80)})
+               value = int32(uint32(value) >> 7)
+       }
+}
+
+// writeString writes a string to a writer, prefixed with its length as a VarInt.
+func writeString(w io.Writer, value string) {
+       writeVarInt(w, int32(len(value)))
+       _, _ = w.Write([]byte(value))

+}
